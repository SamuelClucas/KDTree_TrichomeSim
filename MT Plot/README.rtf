{\rtf1\ansi\ansicpg1252\cocoartf2708
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 ## Prerequisites:\
The programs use some libraries that aren\'92t typically included as inbuilt python modules which you will need to make sure you have installed before you try to run the .py files. They are:\
- vtk (visualisation toolkit)\
- numpy\
- skimage\
- matplotlib\
\
Commands to install libraries varies depending on your machine\'92s operating system.\
If you are on mac, enter \'93pip3 install *libraryname*\'94 into command prompt.\
\
## Introduction:\
There are 2 small .py files written which can be used together to manually label microtubules in a trichome. This works by using MT_Plot_2D to manually select points (x, y, z) in layers of the image stack. Doing so for each microtubule in 2D layers is possible, however sometimes you\'92ll find you need clarification at microtubule intersections, which is where MT_Plot_3D is useful. It uses the .csv file generated by MT_Plot_2D when you \'93commit microtubules\'94 to visualise the points along each microtubule joined by line segments (click \'91visualise CSV\'92 in MT_Plot_2D to see this). In this way, you can be more certain that you are labelling the microtubules correctly. Any errors can simply be manually removed from the .csv file. \
\
## Step 1: Setting up the .py files\
I recommend you install an IDE (I used Thonny as it\'92s very simple to use). This will allow you to edit the .py files correctly. \
\
Open MT_Plot_2D in your IDE of choice:\
1. In line 9 of MT_Plot_2D, a variable called \'93image_stack\'94 is initialised, which uses io.imread(\'91insert/path/to/microtubule/images\'92) to load the .tif image stack. As suggested here, you must insert the path to the image stack you wish to label. Feel free to use the example .tif stack included.\
\
2. In line 10, a variable called \'93csv_file_path\'94 is initialised. This is going to be the filepath that your \'93committed\'94 microtubule point coordinates will be exported to in a .csv file. Replace the string \'91choose/csv/export/location/and/name\'92 - give it a useful name like \'93microtubule_coordinates\'94.\
\
3. Do the same for threeD_path = \'91/path/to/MT_Plot_3D.py' - the file is included in the project folder.\
\
Open MT_Plot_3D in your IDE:\
1. Just as you did before, replace the \'91insert/path/to/microtubule/images\'92 for image_stack on line 8.\
\
2. Again, replace \'91choose/csv/export/location/and/name\'92 on line 11 with the pathname of the .csv MT_Plot_2D will create and export microtubule coordinates to.\
\
## Step 2: Using MT_Plot_2D\
1. Run MT_Plot_2D file.\
\
2. A window will pop up named Figure 1, featuring an image slider, a \'91commit microtubule\'92 button and a \'91clear layer\'92 button. Click and drag the slider to present different layers of the stack in the window. You may also use the left and right arrow keys to more precisely navigate the stack (you can ignore the black buttons in the bottom left of the window).\
\
3. Depending on the signal:noise ratio of your image, the bright pixels will either be a microtubule signal in a layer of the stack or noise - you may want to segment your image stack prior to labelling to eliminate some noise - I recommend using ILASTIK pixel classification. Additionally, you may want to only analyse a selection of the stack to make it more manageable - in FIJI it\'92s simple to do this.\
\
You can click on the image to add a circle centered at the x, y point you clicked on. This circle only exists in this layer of the stack. The idea is that you progress through the stack, labelling the microtubule through the depth of the stack with these circles. If you make a mistake, you can click the clear layer button to remove all the circles in the current layer of the stack (circles in previous layers of the stack will remain).\
\
4. When you are happy that a single microtubule has been labeled with x, y points through the z axis of the stack (it is up to you how precisely you follow the length of the microtubule - more points will more precisely plot the microtubule in 3D space, but will take much more time to label), you can click \'93commit microtubule\'94 - this will do a few things. Firstly, if the microtubule coordinate file you specified to be created at the desired path earlier doesn\'92t exist yet (i.e., it\'92s the first time you are running the program or you deleted the previous .csv file) it will be created - you can check after clicking the button that the file now exists at the specified path. Secondly, all the circles representing points of the microtubule will turn orange to signify they have been \'91committed\'92 - you can no longer clear these circles. Thirdly, if you open the .csv file, you will see X, Y, and Z header columns and below the values for each circle on its own line. These points in sequence represent the microtubule in 3D space. \
\
5. You may now start to label a new microtubule in the Figure 1 window just as you did before. Click commit when you are done, and you\'92ll see in the .csv file there is a line break before a new set of xyz values for the points making up the new microtubule. Rinse and repeat this process until all the microtubules are labelled - READ STEP 3 BEFORE YOU DO SO.\
\
## Step 3: Using MT_Plot_3D (visualising the CSV file)\
1. You may struggle to follow the length of the microtubule throughout the microtubule stack where two microtubules intersect or curve past one another. This is where you use MT_Plot_3D.py. ONE IMPORTANT THING TO NOTE: I originally intended both .py files to be ran as one .py file, but multi-threading both the 3D render and the 2D layer with stack slider was difficult due to libraries clashing. I got around this by running  MT_Plot_3D in a separate instance using the subprocess library - this happens when you click \'91visualise CSV\'92. \
2. A window will pop up called \'91Visualisation Toolkit - Cocoa #1\'92 - the library I have used to render the image stack in 3D. It will print the number of microtubules and points labelled. You can zoom and rotate around the 3D render by clicking and dragging. You should also be able to see green spheres connected by green line segment for each microtubule. If you have used MT_Plot_2D correctly, each microtubule should be isolated in that none of its points join by line segment to a different microtubule - if this isn\'92t the case, you haven\'92t pressed commit microtubule and just moved on to label a new microtubule without exporting any points. In the .csv file, the two sets of microtubule points won\'92t be separated by a line break. This line break is important, as it distinguishes between two different microtubules, and is a sign to MT_Plot_3D which points make up a microtubule and should therefore be connected. If you are confused, I have included a sample set of coordinates labelled for the included example image stack. Make sure you have changed the .py filepath variables accordingly to the example images and example .csv as described in step 1 to visualise the example csv and see how it is done correctly.\
3. To close the 3D render, press the escape key. You can now go back to labelling.\
\
## Areas for improvement:\
You will also realise that MT_Plot_3D does not update as you continue labelling microtubules in MT_Plot_2D. If you want to see new microtubules on the 3D render each time you commit a new microtubule, you will have to rerun MT_Plot_3D by pressing \'91visualise CSV\'92, which is quite inefficient. \
\
}